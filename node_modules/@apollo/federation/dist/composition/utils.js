"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("apollo-server-env");
const apollo_env_1 = require("apollo-env");
const graphql_1 = require("graphql");
function isStringValueNode(node) {
    return node.kind === graphql_1.Kind.STRING;
}
exports.isStringValueNode = isStringValueNode;
function mapFieldNamesToServiceName(fields, serviceName) {
    return fields.reduce((prev, next) => {
        prev[next.name.value] = serviceName;
        return prev;
    }, Object.create(null));
}
exports.mapFieldNamesToServiceName = mapFieldNamesToServiceName;
function findDirectivesOnTypeOrField(node, directiveName) {
    return node && node.directives
        ? node.directives.filter(directive => directive.name.value === directiveName)
        : [];
}
exports.findDirectivesOnTypeOrField = findDirectivesOnTypeOrField;
function stripExternalFieldsFromTypeDefs(typeDefs, serviceName) {
    const strippedFields = [];
    const typeDefsWithoutExternalFields = graphql_1.visit(typeDefs, {
        ObjectTypeExtension: removeExternalFieldsFromExtensionVisitor(strippedFields, serviceName),
        InterfaceTypeExtension: removeExternalFieldsFromExtensionVisitor(strippedFields, serviceName),
    });
    return { typeDefsWithoutExternalFields, strippedFields };
}
exports.stripExternalFieldsFromTypeDefs = stripExternalFieldsFromTypeDefs;
function removeExternalFieldsFromExtensionVisitor(collector, serviceName) {
    return (node) => {
        let fields = node.fields;
        if (fields) {
            fields = fields.filter(field => {
                const externalDirectives = findDirectivesOnTypeOrField(field, 'external');
                if (externalDirectives.length > 0) {
                    collector.push({
                        field,
                        parentTypeName: node.name.value,
                        serviceName,
                    });
                    return false;
                }
                return true;
            });
        }
        return Object.assign({}, node, { fields });
    };
}
function parseSelections(source) {
    return graphql_1.parse(`query { ${source} }`)
        .definitions[0].selectionSet.selections;
}
exports.parseSelections = parseSelections;
function hasMatchingFieldInDirectives({ directives, fieldNameToMatch, namedType, }) {
    return Boolean(namedType.astNode &&
        directives
            .map(keyDirective => keyDirective.arguments &&
            isStringValueNode(keyDirective.arguments[0].value)
            ? {
                typeName: namedType.astNode.name.value,
                keyArgument: keyDirective.arguments[0].value.value,
            }
            : null)
            .filter(apollo_env_1.isNotNullOrUndefined)
            .flatMap(selection => parseSelections(selection.keyArgument))
            .some(field => field.kind === graphql_1.Kind.FIELD && field.name.value === fieldNameToMatch));
}
exports.hasMatchingFieldInDirectives = hasMatchingFieldInDirectives;
exports.logServiceAndType = (serviceName, typeName, fieldName) => `[${serviceName}] ${typeName}${fieldName ? `.${fieldName} -> ` : ' -> '}`;
function errorWithCode(code, message) {
    return new graphql_1.GraphQLError(message, undefined, undefined, undefined, undefined, undefined, {
        code,
    });
}
exports.errorWithCode = errorWithCode;
function findTypesContainingFieldWithReturnType(schema, node) {
    const returnType = graphql_1.getNamedType(node.type);
    if (!graphql_1.isObjectType(returnType))
        return [];
    const containingTypes = [];
    const types = schema.getTypeMap();
    for (const selectionSetType of Object.values(types)) {
        if (!graphql_1.isObjectType(selectionSetType))
            continue;
        const allFields = selectionSetType.getFields();
        Object.values(allFields).forEach(field => {
            const fieldReturnType = graphql_1.getNamedType(field.type);
            if (fieldReturnType === returnType) {
                containingTypes.push(fieldReturnType);
            }
        });
    }
    return containingTypes;
}
exports.findTypesContainingFieldWithReturnType = findTypesContainingFieldWithReturnType;
function findFieldsThatReturnType({ schema, typeToFind, }) {
    if (!graphql_1.isObjectType(typeToFind))
        return [];
    const fieldsThatReturnType = [];
    const types = schema.getTypeMap();
    for (const selectionSetType of Object.values(types)) {
        if (!graphql_1.isObjectType(selectionSetType))
            continue;
        const fieldsOnNamedType = selectionSetType.getFields();
        Object.values(fieldsOnNamedType).forEach(field => {
            const fieldReturnType = graphql_1.getNamedType(field.type);
            if (fieldReturnType === typeToFind) {
                fieldsThatReturnType.push(field);
            }
        });
    }
    return fieldsThatReturnType;
}
exports.findFieldsThatReturnType = findFieldsThatReturnType;
function selectionIncludesField({ selections, selectionSetType, typeToFind, fieldToFind, }) {
    for (const selection of selections) {
        const selectionName = selection.name.value;
        if (selectionName === fieldToFind &&
            graphql_1.isEqualType(selectionSetType, typeToFind))
            return true;
        const typeIncludesField = selectionName &&
            Object.keys(selectionSetType.getFields()).includes(selectionName);
        if (!selectionName || !typeIncludesField)
            continue;
        const returnType = graphql_1.getNamedType(selectionSetType.getFields()[selectionName].type);
        if (!returnType || !graphql_1.isObjectType(returnType))
            continue;
        const subselections = selection.selectionSet && selection.selectionSet.selections;
        if (subselections) {
            const selectionDoesIncludeField = selectionIncludesField({
                selectionSetType: returnType,
                selections: subselections,
                typeToFind,
                fieldToFind,
            });
            if (selectionDoesIncludeField)
                return true;
        }
    }
    return false;
}
exports.selectionIncludesField = selectionIncludesField;
exports.defKindToExtKind = {
    [graphql_1.Kind.SCALAR_TYPE_DEFINITION]: graphql_1.Kind.SCALAR_TYPE_EXTENSION,
    [graphql_1.Kind.OBJECT_TYPE_DEFINITION]: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
    [graphql_1.Kind.INTERFACE_TYPE_DEFINITION]: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
    [graphql_1.Kind.UNION_TYPE_DEFINITION]: graphql_1.Kind.UNION_TYPE_EXTENSION,
    [graphql_1.Kind.ENUM_TYPE_DEFINITION]: graphql_1.Kind.ENUM_TYPE_EXTENSION,
    [graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION]: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
};
//# sourceMappingURL=utils.js.map